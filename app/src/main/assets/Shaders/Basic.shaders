#shader vertex

attribute vec4 a_Position;
attribute vec2 a_TexCoord;
attribute vec3 a_Normal;
attribute vec4 a_Color;
attribute float a_TextureSlot;

varying vec2 v_TexCoord;
varying vec3 v_Normal;
varying vec3 v_CurrentPosition;
varying vec4 v_Color;
varying float v_TextureSlot;

varying vec4 fragPosLight;

uniform mat4 mvpmatrix;
uniform mat4 lightProjection;

void main()
{
    gl_Position = mvpmatrix * vec4(a_Position.x, a_Position.y, a_Position.z, 1.0);
    v_CurrentPosition = vec3(a_Position);
    v_TexCoord = a_TexCoord;
    v_Normal = a_Normal;
    v_Color = a_Color;
    v_TextureSlot =  a_TextureSlot;

    fragPosLight = lightProjection * vec4(a_Position.x, a_Position.y, a_Position.z, 1.0);
}


#shader fragment

precision mediump float;

varying vec2 v_TexCoord;
varying vec3 v_Normal;
varying vec3 v_CurrentPosition;
varying vec4 v_Color;
varying float v_TextureSlot;

varying vec4 fragPosLight;

uniform sampler2D u_Textures[2];
uniform vec3 u_LightPosition;
uniform vec4 u_LightColor;

void main()
{
        int index = int(v_TextureSlot);
        vec4 texColor = texture2D(u_Textures[index], v_TexCoord);

        float a = 1.0 - (1.0 - texColor.w) * (1.0 - v_Color.w);
        float r = (v_Color.r * (1.0 - texColor.w) + texColor.r * texColor.w);
        float g = (v_Color.g * (1.0 - texColor.w) + texColor.g * texColor.w);
        float b = (v_Color.b * (1.0 - texColor.w) + texColor.b * texColor.w);


        // ambient lighting
	    float ambient = 0.2;

        // diffuse lighting
	    vec3 lightDirection = normalize(u_LightPosition - v_CurrentPosition);
	    float diffuse = max(dot(v_Normal, lightDirection), 0.0);



        // Shadow value
        float shadow = 0.0;
        // Sets lightCoords to cull space
        vec3 lightCoords = fragPosLight.xyz / fragPosLight.w;
        if(lightCoords.z <= 1.0)
        {
            // Get from [-1, 1] range to [0, 1] range just like the shadow map
            lightCoords = (lightCoords + 1.0) / 2.0;
            float currentDepth = lightCoords.z;
            // Prevents shadow acne
            float bias = max(0.025 * (1.0 - dot(v_Normal, lightDirection)), 0.0005);

            // Smoothens out the shadows
            float sampleRadius = 2.0;
            vec2 pixelSize = vec2(1.0 / 2048.0, 1.0 / 2048.0);
            for(float y = -sampleRadius; y <= sampleRadius; y++)
            {
                for(float x = -sampleRadius; x <= sampleRadius; x++)
                {
                    float closestDepth = texture2D(u_Textures[1], lightCoords.xy + vec2(x, y) * pixelSize).r;
                    if (currentDepth > closestDepth + bias)
                        shadow += 1.0;
                }
            }
            // Get average shadow
            shadow /= pow((sampleRadius * 2.0 + 1.0), 2.0);

        }



        vec4 lightColor = u_LightColor * (diffuse * (1.0 - shadow) + ambient);
        lightColor.w = 1.0;

        gl_FragColor = vec4(r, g, b, a) * lightColor;
}